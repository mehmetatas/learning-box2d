package com.turpgames.physics;

import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.QueryCallback;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.joints.MouseJoint;
import com.turpgames.input.GdxInputManager;
import com.turpgames.input.InputListener;
import com.turpgames.physics.box2d.builders.Box2DBuilders;
import com.turpgames.physics.box2d.builders.MouseJointBuilder;

public class PhysicsGame implements ApplicationListener {
	private GameWorld gameWorld;

	private Body hitBody;
	private MouseJoint mouseJoint;
	private MouseJointBuilder mouseJointBuilder;
	private final Vector2 target = new Vector2();
	private final Vector3 testPoint = new Vector3();
	private final QueryCallback callback = new QueryCallback() {
		@Override
		public boolean reportFixture(Fixture fixture) {
			// if the hit point is inside the fixture of the body
			// we report it
			if (fixture.testPoint(testPoint.x, testPoint.y)) {
				hitBody = fixture.getBody();
				return false;
			} else
				return true;
		}
	};

	@Override
	public void create() {
		float width = Gdx.graphics.getWidth();
		float height = Gdx.graphics.getHeight();

		gameWorld = GameWorld.newBuilder().gravity(0, -10f).viewport(GameWorld.scale * width, GameWorld.scale * height).build();

		FixedPart fixedPart = new FixedPart(gameWorld);
		Ball ball = new Ball(gameWorld, 0.75f, 1.75f, 0.05f);

		final float chainHeight = 0.1f;

		Ring[] chain = new Ring[10];
		for (int i = 0; i < chain.length; i++) {
			chain[i] = new Ring(gameWorld, 0.75f, 1.50f + (i * chainHeight), 0.01f, chainHeight);
			if (i > 0) {
				Box2DBuilders.Joint.newRevoluteJointBuilder()
						.setBodyA(chain[i - 1].body)
						.setBodyB(chain[i].body)
						.setLocalAnchorA(0, chainHeight / 2f)
						.setLocalAnchorB(0, -chainHeight / 2f)
						.build(gameWorld.getWorld());
			}
		}

		Box2DBuilders.Joint.newRevoluteJointBuilder()
				.setBodyA(ball.body)
				.setBodyB(chain[0].body)
				.setLocalAnchorB(0, -chainHeight / 2f)
				.build(gameWorld.getWorld());

		Box2DBuilders.Joint.newRevoluteJointBuilder()
				.setBodyA(chain[chain.length - 1].body)
				.setBodyB(fixedPart.body)
				.setLocalAnchorA(0, chainHeight / 2f)
				.build(gameWorld.getWorld());

		mouseJointBuilder = Box2DBuilders.Joint.newMouseJointBuilder()
				.setCollideConnected(true)
				.setBodyA(fixedPart.body);

		// RopeJoint2.build(gameWorld.getWorld(), ball.body, fixedPart.body,
		// ball.body.getPosition().x, ball.body.getPosition().y, 1f, 4);

		// Box2DBuilders.Joint.newRopeJointBuilder()
		// .setBodyA(fixedPart.body)
		// .setBodyB(ball.body)
		// .setLocalAnchorB(0f, 0.0f)
		// .setMaxLength(1.5f)
		// .build(gameWorld.getWorld());
		//
		// Box2DBuilders.Joint.newDistanceJointBuilder()
		// .setBodyA(fixedPart.body)
		// .setBodyB(ball.body)
		// .setLocalAnchorB(0f, 0.0f)
		// .setLength(1.5f)
		// .build(gameWorld.getWorld());

		// new Person(gameWorld);

		Room.newBuilder()
				.setPosition(0, 0)
				.setSize(gameWorld.getWidth(), gameWorld.getHeight())
				.setWallThickness(0.1f)
				.build(gameWorld);

		GdxInputManager.instance.activate();

		GdxInputManager.instance.registerListener(new InputListener() {
			@Override
			public boolean touchDown(float x, float y, int pointer) {
				// translate the mouse coordinates to world coordinates
				gameWorld.unproject(testPoint.set(x, y, 0));
				// ask the world which bodies are within the given
				// bounding box around the mouse pointer
				hitBody = null;
				gameWorld.getWorld().QueryAABB(callback, testPoint.x - 0.001f, testPoint.y - 0.001f, testPoint.x + 0.001f, testPoint.y + 0.001f);

				// ignore kinematic bodies, they don't work with the mouse joint
				if (hitBody == null || hitBody.getType() != BodyType.DynamicBody)
					return false;

				// if we hit something we create a new mouse joint
				// and attach it to the hit body.
				if (hitBody != null) {
					mouseJoint = mouseJointBuilder.setBodyB(hitBody)
							.setTarget(testPoint.x, testPoint.y)
							.setMaxForce(1000.0f * hitBody.getMass())
							.build(gameWorld.getWorld());

					hitBody.setAwake(true);
				}

				return false;
			}

			/** another temporary vector **/

			@Override
			public boolean touchDragged(float x, float y, int pointer) {
				// if a mouse joint exists we simply update
				// the target of the joint based on the new
				// mouse coordinates
				if (mouseJoint != null) {
					gameWorld.unproject(testPoint.set(x, y, 0));
					mouseJoint.setTarget(target.set(testPoint.x, testPoint.y));
				}
				return false;
			}

			@Override
			public boolean touchUp(float x, float y, int pointer) {
				// if a mouse joint exists we simply destroy it
				if (mouseJoint != null) {
					gameWorld.getWorld().destroyJoint(mouseJoint);
					mouseJoint = null;
				}
				return false;
			}
		});
	}

	@Override
	public void render() {
		gameWorld.update();
		gameWorld.render();
	}

	@Override
	public void dispose() {
		gameWorld.dispose();
	}

	@Override
	public void resize(int width, int height) {
	}

	@Override
	public void pause() {
	}

	@Override
	public void resume() {
	}
}
